---
layout: post
title: Implementando una ALU - CS01
published: false
---

En esta ocasión el objetivo es implementar una ALU (Arithmetic-Logic-Unit) la cual es una parte fundamental de nuestra CPU que se encarga de realizar operaciones aritmeticas y logicas, para ello iremos implementando progresivamente otros chips que son necesarios y tenemos la restricción de que solo se pueden usar CHIPS previamente implementados.

Los chips que deben ser implementados son:
- Half Adder
- Full Adder
- 16-bit Adder
- 16-bit Incrementer
- Arithmetic Logic Unit (ALU)

# Tabla de contenidos

- Conocimientos importantes
  * Complemento a 2
  * Identificando los numeros negativos en n-bits usando complemento a 2 (reto 2)
  * El rango de valores representables en n-bits usando complemento a 2 (reto 1, 3, 4)
  * Sumas y restas usando complemento a 2 (reto 5, 6, 7)
  * Los computador y el complemento a 2 (reto 8)
  * Diferencias entre un half adder y un full adder (reto 9)
  * Significado del carry de una suma (reto 10)    
- Implementando el half adder
- Implementando el full adder
- Implementando el 16-bit Adder
- Implementando el 16-bit Incrementer
- Implementando la ALU
  * Analizando el OR y otras operaciones con esta ALU (reto maestro)
  * Ejemplos de uso (reto 11)
- Lista de chequeo y autoevaluacion

# Conocimientos importantes

## Complemento a 2
El complemento a 2 se puede ver como una tecnica que me permite representar numeros negativos en binario, existen varias formas de hallarlo dado un numero positivo en base 2.

Por ejemplo si tenemos el 2 en 4 bits (0010) y queremos hallar como se representaria el -2 en 4-bits se podria hallar el complemento a 1 de 0010 es decir ~0010=1101 y luego a ese resultado sumarle un 1 (0001), 1101+0001=1110, lo cual significa que el -2 se representaria como 1110 en complemento a 2 de 4-bits.

Cabe decir que tambien se puede usar el complemento a 2 para hacer el proceso contrario, es decir, sea la representación de un numero negativo 1110, ¿cual es la representación positiva de dicho numero?

(~1110)+0001=0001+0001=0010 (2 base_10)

## Identificando los numeros negativos en n-bits usando complemento a 2

> Poner imagen: complemento_a_2_relaciones_1.jpg

En esta imagen hay dos puntos importantes a notar: 1) si tomamos un numero negativo, por ejemplo -1 y lo escribimos en complemento a 2 de 8 bits vemos que todos sus bits estan en **true**, y si luego lo representamos en un complemento a 2 de 16-bits los 8 bits extra siguen teniendo un valor de 1, es decir, no importa la cantidad de bits con la que representemos un numero negativo (o positivo) el complemento a 2 funcionará correctamente mientras se intente representar un número en el rango posible.

La segunda observación, es que vemos que si un numero es menor a 0 (negativo) el bit mas significativo (MSB) es 1 siempre en cambio cuando sea mayor o igual a 0 el MSB siempre es 0, aunque esta tabla no tenga todos los posible valores, si vemos una tabla completa se puede verificar la afirmación mencionada.

## El rango de valores representables en n-bits usando complemento a 2
¿Si usamos complemento a 2 y tenemos 8 bits cuantos números podemos representar y cuales?
La primera pregunta se puede responder facílmente acudiendo a la teoria de la combinatoria, dado que nos encontramos ante un problema de variación con repetición seria cuestion de elevar 2 a la n bits, donde n es la cantidad de bits que puede usarse para representar un número.

La segunda pregunta por otra parte requiere un poco mas de observación por lo que se intentara abordar a travez de varios ejercicios.

Que pasa si se quiere expresar en complemento a 2 con 8 bits en base 2 los siguientes números: 1, 0, -1, -128, 127, 128, -130:
```
1 = 0000 0001
0 = 0000 0000
-1 = 1111 1111
-128 = 1000 0000
127 = 0111 1111
128 = 1000 0000
```
Acaba de ocurrir algo interesante, el -1 y el 128 tienen la misma representación complemento a 2, ¿o no? 

